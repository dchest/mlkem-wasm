// src/build/wasm-module.js
async function MLKEM768Module(moduleArg = {}) {
  var moduleRtn;
  var Module = moduleArg;
  var ENVIRONMENT_IS_WEB = typeof window == "object";
  var ENVIRONMENT_IS_WORKER = typeof WorkerGlobalScope != "undefined";
  var ENVIRONMENT_IS_NODE = typeof process == "object" && process.versions?.node && process.type != "renderer";
  var _scriptName = import.meta.url;
  var scriptDirectory = "";
  var readAsync, readBinary;
  if (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) {
    try {
      scriptDirectory = new URL(".", _scriptName).href;
    } catch {
    }
    {
      if (ENVIRONMENT_IS_WORKER) {
        readBinary = (url) => {
          var xhr = new XMLHttpRequest();
          xhr.open("GET", url, false);
          xhr.responseType = "arraybuffer";
          xhr.send(null);
          return new Uint8Array(xhr.response);
        };
      }
      readAsync = async (url) => {
        if (isFileURI(url)) {
          return new Promise((resolve, reject) => {
            var xhr = new XMLHttpRequest();
            xhr.open("GET", url, true);
            xhr.responseType = "arraybuffer";
            xhr.onload = () => {
              if (xhr.status == 200 || xhr.status == 0 && xhr.response) {
                resolve(xhr.response);
                return;
              }
              reject(xhr.status);
            };
            xhr.onerror = reject;
            xhr.send(null);
          });
        }
        var response = await fetch(url, { credentials: "same-origin" });
        if (response.ok) {
          return response.arrayBuffer();
        }
        throw new Error(response.status + " : " + response.url);
      };
    }
  } else {
  }
  var out = console.log.bind(console);
  var err = console.error.bind(console);
  var wasmBinary;
  var ABORT = false;
  var isFileURI = (filename) => filename.startsWith("file://");
  var readyPromiseResolve, readyPromiseReject;
  var wasmMemory;
  var HEAP8, HEAPU8, HEAP16, HEAPU16, HEAP32, HEAPU32, HEAPF32, HEAPF64;
  var HEAP64, HEAPU64;
  var runtimeInitialized = false;
  function updateMemoryViews() {
    var b = wasmMemory.buffer;
    Module["HEAP8"] = HEAP8 = new Int8Array(b);
    HEAP16 = new Int16Array(b);
    Module["HEAPU8"] = HEAPU8 = new Uint8Array(b);
    HEAPU16 = new Uint16Array(b);
    HEAP32 = new Int32Array(b);
    HEAPU32 = new Uint32Array(b);
    HEAPF32 = new Float32Array(b);
    HEAPF64 = new Float64Array(b);
    HEAP64 = new BigInt64Array(b);
    HEAPU64 = new BigUint64Array(b);
  }
  function preRun() {
  }
  function initRuntime() {
    runtimeInitialized = true;
    wasmExports["b"]();
  }
  function postRun() {
  }
  var runDependencies = 0;
  var dependenciesFulfilled = null;
  function addRunDependency(id) {
    runDependencies++;
  }
  function removeRunDependency(id) {
    runDependencies--;
    if (runDependencies == 0) {
      if (dependenciesFulfilled) {
        var callback = dependenciesFulfilled;
        dependenciesFulfilled = null;
        callback();
      }
    }
  }
  function abort(what) {
    what = "Aborted(" + what + ")";
    err(what);
    ABORT = true;
    what += ". Build with -sASSERTIONS for more info.";
    var e = new WebAssembly.RuntimeError(what);
    readyPromiseReject?.(e);
    throw e;
  }
  var wasmBinaryFile;
  function findWasmBinary() {
    return base64Decode("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ADcDACADQcgJakIANwMAIANBwAlqQgA3AwAgA0IANwO4CSADQgA3A7AJIANCADcDqAkgA0IANwOgCSADQZgJakIANwMAIANBkAlqQgA3AwAgA0GICWpCADcDACADQYAJakIANwMAIANCADcD+AggA0IANwPwCCADQgA3A+gIIANCADcD4AggA0EAQeAI/AsAQQAhBQskACAFC88DAQh/IwAiBCAEQYAVa0FgcSIEJAAgBEGACWoiBSACEBYgBRALIAQgBRAXQQAhBQNAIAQgBkECaiIHai0AACACIAdqLQAAcyIHIAQgBkEBaiIJai0AACACIAlqLQAAcyIJIAQgBmotAAAgAiAGai0AAHMiCyAIc3NzIQggByAJIAUgC3JyciEFIAZBA2oiBkGACUcNAAsgBEEAQYAJ/AsAIARBgAlqIgZBAEGADPwLACAIQQAgBUH/AXFrQRh2c0F/IQVB/wFxIAhB/wFxRgRAIAQgAykAADcDgAkgBCADKQAYNwOYCSAEIAMpABA3A5AJIAQgAykACDcDiAkgBEGgCWoiAyACEBMgBCAGQcAAEBIgACAGIAIgBEEgahAaIAEgBCkDGDcAGCABIAQpAxA3ABAgASAEKQMINwAIIAEgBCkDADcAACADQgA3AwAgBEGoCWpCADcDACAEQbAJakIANwMAIARBuAlqQgA3AwAgBEIANwOACSAEQgA3A4gJIARCADcDkAkgBEIANwOYCSAEQgA3AzggBEIANwMwIARCADcDKCAEQgA3AyAgBEIANwMYIARCADcDECAEQgA3AwggBEIANwMAQQAhBQskACAFC5UHAgp/BH4jACIDIANBgM8Aa0FgcSIDJAAgAikACCENIAIpABAhDiACKQAYIQ8gAikAACEQIANBAzoAICADIA83AxggAyAONwMQIAMgDTcDCCADIBA3AwAgA0HAzgBqIANBIRASIANBiB9qIAMpA8hOIg03AwAgA0GQH2ogAykD0E4iDjcDACADQZgfaiADKQPYTiIPNwMAIANByB9qIA03AwAgA0HQH2ogDjcDACADQdgfaiAPNwMAIANBmCBqIA83AwAgA0GQIGogDjcDACADQYggaiANNwMAIAMgDzcD2B4gAyAONwPQHiADIA03A8geIAMgAykDwE4iDTcDwB4gAyANNwOAHyADIA03A8AfIAMgDTcDgCAgA0GAAjsBoCAgA0ECOwHgHyADQQE7AaAfIANBADsB4B4gA0HAKmoiCCADQcAuaiADQcAyaiADQcA2aiILIANBwB5qIgYQCSADQYEEOwGgICADQYAEOwHgHyADQYICOwGgHyADQYECOwHgHiADQcA6aiADQcA+aiADQcDCAGoiDCADQcDGAGogBhAJIANBggQ7AeAeIANBwMoAaiAGEB8gBkEAQYAC/AsAIANBwAZqIgQgA0HACmogA0HADmogA0HAEmoiBSADQeDOAGoiCUEAQQFBAkH/ARAKIAYgA0HAImogA0HAJmogBSAJQQNBBEEFQf8BEAogBBAMIAYQDCADQUBrIgcgBBAVIAUgCCAEIAcQAiADQcAWaiALIAQgBxACIANBwBpqIAwgBCAHEAIgBRAOIAVBgARqEA4gBUGACGoQDiAFIAYQICAFEAsgBBALIAEgBBAXIAAgBRAXIABBmAlqIAMpA9hONwAAIABBkAlqIAMpA9BONwAAIABBiAlqIAMpA8hONwAAIAAgAykDwE43AIAJIAlCADcDACADQejOAGpCADcDACADQfDOAGpCADcDACADQfjOAGpCADcDACADQgA3A8BOIANCADcDyE4gA0IANwPQTiADQgA3A9hOIANBADoAICADQgA3AxggA0IANwMQIANCADcDCCADQgA3AwAgCEEAQYAk/AsAIAZBAEGADPwLACAEQQBBgAz8CwAgB0EAQYAG/AsAJAAgAUGACWogAEGgCfwKAAAgAUGgEmogABATIAFB2BJqIAIpADg3AAAgAUHQEmogAikAMDcAACABQcgSaiACKQAoNwAAIAEgAikAIDcAwBJBAAsCAAsLyAMBAEGACAvAA+z7Cv2Z/hP61QWOBR8BygBV/24CKQa2AMIDTvs++rwFPQLT+ggBfwHD/LIFvvl+/1f9+QPcAmAC+vmbATP/3fnHBIwC2P33A/P60wXm/vj5BAL4/8D+Zv2u+Xb7fgC9Bav8pv/x/j4DawBz+gn/Sfxy/sEDHPor/cAB1/ulAgX7sfuuASsCSwMd+2cDDgZpAKYBSwKxABX/3f40/iYGdQYK/woDhwRt//f8ywWm/V8EyvmEApj8XQGiAUkBZP+1/zEDSQRbAmICKgX7+kf6gAFB+3j/wgTJ+pb83ABd+4X5X/sG+gL7GgMa+qr8mvzeAZT/zP7kA98DvgNM+vIFXAYBAAAAAAAAAIKAAAAAAAAAioAAAAAAAIAAgACAAAAAgIuAAAAAAAAAAQAAgAAAAACBgACAAAAAgAmAAAAAAACAigAAAAAAAACIAAAAAAAAAAmAAIAAAAAACgAAgAAAAACLgACAAAAAAIsAAAAAAACAiYAAAAAAAIADgAAAAAAAgAKAAAAAAACAgAAAAAAAAIAKgAAAAAAAAAoAAIAAAACAgYAAgAAAAICAgAAAAAAAgAEAAIAAAAAACIAAgAAAAIA=");
  }
  function getBinarySync(file) {
    if (ArrayBuffer.isView(file)) {
      return file;
    }
    if (readBinary) {
      return readBinary(file);
    }
    throw "both async and sync fetching of the wasm failed";
  }
  async function getWasmBinary(binaryFile) {
    return getBinarySync(binaryFile);
  }
  async function instantiateArrayBuffer(binaryFile, imports) {
    try {
      var binary = await getWasmBinary(binaryFile);
      var instance = await WebAssembly.instantiate(binary, imports);
      return instance;
    } catch (reason) {
      err(`failed to asynchronously prepare wasm: ${reason}`);
      abort(reason);
    }
  }
  async function instantiateAsync(binary, binaryFile, imports) {
    return instantiateArrayBuffer(binaryFile, imports);
  }
  function getWasmImports() {
    return { a: wasmImports };
  }
  async function createWasm() {
    function receiveInstance(instance, module) {
      wasmExports = instance.exports;
      wasmMemory = wasmExports["a"];
      updateMemoryViews();
      assignWasmExports(wasmExports);
      removeRunDependency("wasm-instantiate");
      return wasmExports;
    }
    addRunDependency("wasm-instantiate");
    function receiveInstantiationResult(result2) {
      return receiveInstance(result2["instance"]);
    }
    var info = getWasmImports();
    wasmBinaryFile ??= findWasmBinary();
    var result = await instantiateAsync(wasmBinary, wasmBinaryFile, info);
    var exports = receiveInstantiationResult(result);
    return exports;
  }
  class ExitStatus {
    name = "ExitStatus";
    constructor(status) {
      this.message = `Program terminated with exit(${status})`;
      this.status = status;
    }
  }
  var base64Decode = (b64) => {
    var b1, b2, i2 = 0, j = 0, bLength = b64.length;
    var output = new Uint8Array((bLength * 3 >> 2) - (b64[bLength - 2] == "=") - (b64[bLength - 1] == "="));
    for (; i2 < bLength; i2 += 4, j += 3) {
      b1 = base64ReverseLookup[b64.charCodeAt(i2 + 1)];
      b2 = base64ReverseLookup[b64.charCodeAt(i2 + 2)];
      output[j] = base64ReverseLookup[b64.charCodeAt(i2)] << 2 | b1 >> 4;
      output[j + 1] = b1 << 4 | b2 >> 2;
      output[j + 2] = b2 << 6 | base64ReverseLookup[b64.charCodeAt(i2 + 3)];
    }
    return output;
  };
  function getValue(ptr, type = "i8") {
    if (type.endsWith("*")) type = "*";
    switch (type) {
      case "i1":
        return HEAP8[ptr];
      case "i8":
        return HEAP8[ptr];
      case "i16":
        return HEAP16[ptr >> 1];
      case "i32":
        return HEAP32[ptr >> 2];
      case "i64":
        return HEAP64[ptr >> 3];
      case "float":
        return HEAPF32[ptr >> 2];
      case "double":
        return HEAPF64[ptr >> 3];
      case "*":
        return HEAPU32[ptr >> 2];
      default:
        abort(`invalid type for getValue: ${type}`);
    }
  }
  function setValue(ptr, value, type = "i8") {
    if (type.endsWith("*")) type = "*";
    switch (type) {
      case "i1":
        HEAP8[ptr] = value;
        break;
      case "i8":
        HEAP8[ptr] = value;
        break;
      case "i16":
        HEAP16[ptr >> 1] = value;
        break;
      case "i32":
        HEAP32[ptr >> 2] = value;
        break;
      case "i64":
        HEAP64[ptr >> 3] = BigInt(value);
        break;
      case "float":
        HEAPF32[ptr >> 2] = value;
        break;
      case "double":
        HEAPF64[ptr >> 3] = value;
        break;
      case "*":
        HEAPU32[ptr >> 2] = value;
        break;
      default:
        abort(`invalid type for setValue: ${type}`);
    }
  }
  var stackRestore = (val) => __emscripten_stack_restore(val);
  var stackSave = () => _emscripten_stack_get_current();
  var stackAlloc = (sz) => __emscripten_stack_alloc(sz);
  for (var base64ReverseLookup = new Uint8Array(123), i = 25; i >= 0; --i) {
    base64ReverseLookup[48 + i] = 52 + i;
    base64ReverseLookup[65 + i] = i;
    base64ReverseLookup[97 + i] = 26 + i;
  }
  base64ReverseLookup[43] = 62;
  base64ReverseLookup[47] = 63;
  {
  }
  Module["stackSave"] = stackSave;
  Module["stackRestore"] = stackRestore;
  Module["stackAlloc"] = stackAlloc;
  Module["setValue"] = setValue;
  Module["getValue"] = getValue;
  var _mlkem768_keypair_derand, _mlkem768_enc_derand, _mlkem768_dec, __emscripten_stack_restore, __emscripten_stack_alloc, _emscripten_stack_get_current;
  function assignWasmExports(wasmExports2) {
    Module["_mlkem768_keypair_derand"] = _mlkem768_keypair_derand = wasmExports2["c"];
    Module["_mlkem768_enc_derand"] = _mlkem768_enc_derand = wasmExports2["d"];
    Module["_mlkem768_dec"] = _mlkem768_dec = wasmExports2["e"];
    __emscripten_stack_restore = wasmExports2["f"];
    __emscripten_stack_alloc = wasmExports2["g"];
    _emscripten_stack_get_current = wasmExports2["h"];
  }
  var wasmImports = {};
  var wasmExports = await createWasm();
  function run() {
    if (runDependencies > 0) {
      dependenciesFulfilled = run;
      return;
    }
    preRun();
    if (runDependencies > 0) {
      dependenciesFulfilled = run;
      return;
    }
    function doRun() {
      Module["calledRun"] = true;
      if (ABORT) return;
      initRuntime();
      readyPromiseResolve?.(Module);
      postRun();
    }
    {
      doRun();
    }
  }
  function preInit() {
  }
  preInit();
  run();
  if (runtimeInitialized) {
    moduleRtn = Module;
  } else {
    moduleRtn = new Promise((resolve, reject) => {
      readyPromiseResolve = resolve;
      readyPromiseReject = reject;
    });
  }
  ;
  return moduleRtn;
}
var wasm_module_default = MLKEM768Module;

// src/mlkem.ts
var ALGORITHM_NAME = "ML-KEM-768";
var JWK_ALG = "MLKEM768";
var KEY_USAGES = [
  "encapsulateKey",
  "encapsulateBits",
  "decapsulateKey",
  "decapsulateBits"
];
var MlKemOperationError = class extends Error {
  constructor(message) {
    super(message);
    this.name = "OperationError";
  }
};
var MlKemInvalidAccessError = class extends Error {
  constructor(message) {
    super(message);
    this.name = "InvalidAccessError";
  }
};
var MlKemNotSupportedError = class extends Error {
  constructor(message) {
    super(message);
    this.name = "NotSupportedError";
  }
};
var MlKemDataError = class extends Error {
  constructor(message) {
    super(message);
    this.name = "DataError";
  }
};
var _publicKeyData = Symbol();
var _privateSeed = Symbol();
var _privateSecretKey = Symbol();
var MlKemCryptoKey = class {
  #algorithm;
  #type;
  #usages;
  #extractable;
  #publicKeyData;
  #privateSeed;
  #privateSecretKey;
  constructor(algorithm, type, usages, extractable, publicKeyData, privateSeed = null, privateSecretKey = null) {
    this.#algorithm = algorithm;
    this.#type = type;
    this.#usages = usages;
    this.#extractable = extractable;
    this.#publicKeyData = publicKeyData;
    this.#privateSeed = privateSeed;
    this.#privateSecretKey = privateSecretKey;
  }
  get algorithm() {
    return this.#algorithm;
  }
  get type() {
    return this.#type;
  }
  get usages() {
    return this.#usages;
  }
  get extractable() {
    return this.#extractable;
  }
  get [_publicKeyData]() {
    return this.#publicKeyData;
  }
  get [_privateSeed]() {
    return this.#privateSeed;
  }
  get [_privateSecretKey]() {
    return this.#privateSecretKey;
  }
};
function toBase64url(data) {
  return btoa(String.fromCharCode(...data)).replace(/\+/g, "-").replace(/\//g, "_").replace(/=+$/, "");
}
function fromBase64url(base64url) {
  const base64 = base64url.replace(/-/g, "+").replace(/_/g, "/");
  const binary = atob(base64 + "===".slice((base64.length + 3) % 4));
  return Uint8Array.from(binary, (c) => c.charCodeAt(0));
}
var PUBLICKEY_BYTES = 1184;
var SECRETKEY_BYTES = 2400;
var CIPHERTEXT_BYTES = 1088;
var SHARED_SECRET_BYTES = 32;
var KEYPAIR_RANDOM_BYTES = 64;
var ENC_RANDOM_BYTES = 32;
var MlKem768 = class {
  #module;
  async #getModule() {
    if (!this.#module) {
      this.#module = await wasm_module_default();
    }
    return this.#module;
  }
  #checkAlgorithm(algorithm) {
    const name = typeof algorithm === "string" ? algorithm : typeof algorithm === "object" && algorithm !== null ? algorithm.name : null;
    if (name !== ALGORITHM_NAME) {
      throw new TypeError("Unsupported algorithm");
    }
  }
  async #generateKeyPair(coins) {
    const module = await this.#getModule();
    const stackSave = module.stackSave();
    try {
      const pkPtr = module.stackAlloc(PUBLICKEY_BYTES);
      const skPtr = module.stackAlloc(SECRETKEY_BYTES);
      const coinsPtr = module.stackAlloc(KEYPAIR_RANDOM_BYTES);
      module.HEAPU8.set(coins, coinsPtr);
      const result = module._mlkem768_keypair_derand(pkPtr, skPtr, coinsPtr);
      if (result !== 0) {
        throw new Error("Key generation failed");
      }
      const rawPublicKey = new Uint8Array(PUBLICKEY_BYTES);
      const rawSecretKey = new Uint8Array(SECRETKEY_BYTES);
      const rawSeed = new Uint8Array(coins);
      rawPublicKey.set(module.HEAPU8.subarray(pkPtr, pkPtr + PUBLICKEY_BYTES));
      rawSecretKey.set(module.HEAPU8.subarray(skPtr, skPtr + SECRETKEY_BYTES));
      module.HEAPU8.fill(0, pkPtr, pkPtr + PUBLICKEY_BYTES);
      module.HEAPU8.fill(0, skPtr, skPtr + SECRETKEY_BYTES);
      module.HEAPU8.fill(0, coinsPtr, coinsPtr + KEYPAIR_RANDOM_BYTES);
      return { rawPublicKey, rawSecretKey, rawSeed };
    } finally {
      module.stackRestore(stackSave);
    }
  }
  async generateKey(keyAlgorithm, extractable, usages) {
    this.#checkAlgorithm(keyAlgorithm);
    if (!Array.isArray(usages) || usages.some((usage) => !KEY_USAGES.includes(usage))) {
      throw new SyntaxError("Invalid key usages");
    }
    const { rawPublicKey, rawSecretKey, rawSeed } = await this.#generateKeyPair(
      crypto.getRandomValues(new Uint8Array(KEYPAIR_RANDOM_BYTES))
    );
    const algorithm = { name: ALGORITHM_NAME };
    const publicKey = new MlKemCryptoKey(
      algorithm,
      "public",
      usages.filter(
        (usage) => usage === "encapsulateKey" || usage === "encapsulateBits"
      ),
      true,
      rawPublicKey
    );
    const privateKey = new MlKemCryptoKey(
      algorithm,
      "private",
      usages.filter(
        (usage) => usage === "decapsulateKey" || usage === "decapsulateBits"
      ),
      extractable,
      rawPublicKey,
      rawSeed,
      rawSecretKey
    );
    return {
      publicKey,
      privateKey
    };
  }
  async exportKey(format, key) {
    if (!key.extractable) {
      throw new MlKemOperationError("Key is not extractable");
    }
    if (format === "raw-public") {
      if (key.type !== "public") {
        throw new TypeError("Expected key type to be 'public'");
      }
      return new Uint8Array(key[_publicKeyData]).buffer;
    }
    if (format === "raw-seed") {
      if (key.type !== "private") {
        throw new MlKemInvalidAccessError("Expected key type to be 'private'");
      }
      return new Uint8Array(key[_privateSeed]).buffer;
    }
    if (format === "jwk") {
      const jwk = {
        // 2.2. Set the kty attribute of jwk to "AKP".
        kty: "AKP",
        // 2.3. Set the alg attribute of jwk to the alg value corresponding to
        // the name member of normalizedAlgorithm indicated in Section 8 of
        // [draft-ietf-jose-pqc-kem-01] (Figure 1).
        alg: JWK_ALG,
        // 2.4. Set the pub attribute of jwk to the base64url encoded public
        // key corresponding to the [[handle]] internal slot of key.
        pub: toBase64url(key[_publicKeyData])
      };
      if (key.type === "private") {
        jwk.priv = toBase64url(key[_privateSeed]);
      }
      jwk.key_ops = key.usages;
      jwk.ext = key.extractable;
      return jwk;
    }
    throw new MlKemNotSupportedError("Format not supported");
  }
  async importKey(format, keyData, algorithm, extractable, usages) {
    this.#checkAlgorithm(algorithm);
    if (format === "raw-public") {
      if (!Array.isArray(usages) || usages.some(
        (usage) => usage !== "encapsulateKey" && usage !== "encapsulateBits"
      )) {
        throw new SyntaxError("Invalid key usages for public key");
      }
      const data = ArrayBuffer.isView(keyData) ? new Uint8Array(keyData.buffer, keyData.byteOffset, keyData.byteLength) : new Uint8Array(keyData);
      return new MlKemCryptoKey(
        { name: ALGORITHM_NAME },
        "public",
        usages,
        true,
        // extractable
        data
      );
    }
    if (format === "raw-seed") {
      if (!Array.isArray(usages) || usages.some(
        (usage) => usage !== "decapsulateKey" && usage !== "decapsulateBits"
      )) {
        throw new SyntaxError("Invalid key usages for private key");
      }
      const data = ArrayBuffer.isView(keyData) ? new Uint8Array(keyData.buffer, keyData.byteOffset, keyData.byteLength) : new Uint8Array(keyData);
      if (data.length !== KEYPAIR_RANDOM_BYTES) {
        throw new MlKemDataError("Invalid key length");
      }
      const { rawPublicKey, rawSecretKey, rawSeed } = await this.#generateKeyPair(data);
      return new MlKemCryptoKey(
        { name: ALGORITHM_NAME },
        "private",
        usages,
        true,
        // extractable
        rawPublicKey,
        rawSeed,
        rawSecretKey
      );
    }
    if (format === "jwk") {
      if (typeof keyData !== "object" || keyData === null) {
        throw new MlKemDataError(
          "Expected keyData to be a JsonWebKey dictionary"
        );
      }
      const jwk = keyData;
      if (jwk.priv && usages.some(
        (usage) => usage !== "decapsulateKey" && usage !== "decapsulateBits"
      )) {
        throw new SyntaxError("Invalid key usages for private key");
      }
      if (!jwk.priv && usages.some(
        (usage) => usage !== "encapsulateKey" && usage !== "encapsulateBits"
      )) {
        throw new SyntaxError("Invalid key usages for public key");
      }
      if (jwk.kty !== "AKP") {
        throw new MlKemDataError("Invalid key type");
      }
      if (jwk.alg !== JWK_ALG && jwk.alg !== "ML-KEM-768+A192KW") {
        throw new MlKemDataError("Invalid algorithm");
      }
      if (usages.length > 0 && jwk.use && jwk.use !== "enc") {
        throw new MlKemDataError("Invalid key usage");
      }
      if (jwk.key_ops && Array.isArray(jwk.key_ops) && !Array.prototype.every.call(
        jwk.key_ops,
        (op) => KEY_USAGES.includes(op)
      ) || !Array.isArray(jwk.key_ops)) {
        throw new MlKemDataError("Invalid key operations");
      }
      if (jwk.ext === false && extractable) {
        throw new MlKemDataError("Invalid key extractability");
      }
      if (jwk.priv) {
        try {
          const seedData = fromBase64url(jwk.priv);
          if (seedData.length !== KEYPAIR_RANDOM_BYTES) {
            throw new MlKemDataError("Invalid private key length");
          }
          const { rawPublicKey, rawSecretKey, rawSeed } = await this.#generateKeyPair(seedData);
          const key = new MlKemCryptoKey(
            { name: ALGORITHM_NAME },
            "private",
            usages,
            extractable,
            rawPublicKey,
            rawSeed,
            rawSecretKey
          );
          if (toBase64url(rawPublicKey) !== jwk.pub) {
            throw new MlKemDataError("Invalid public key data");
          }
          return key;
        } catch {
          throw new MlKemDataError("Invalid private key format");
        }
      } else {
        try {
          const publicKeyData = fromBase64url(jwk.pub);
          if (publicKeyData.length !== PUBLICKEY_BYTES) {
            throw new MlKemDataError("Invalid public key data");
          }
          return new MlKemCryptoKey(
            { name: ALGORITHM_NAME },
            "public",
            usages,
            extractable,
            publicKeyData
          );
        } catch {
          throw new MlKemDataError("Invalid public key format");
        }
      }
    }
    throw new MlKemNotSupportedError("Unsupported key format");
  }
  // Internal: implements encapsulateBits without checking key usages.
  async #encapsulate(algorithm, encapsulationKey, usage) {
    const module = await this.#getModule();
    this.#checkAlgorithm(algorithm);
    if (!(encapsulationKey instanceof MlKemCryptoKey) || encapsulationKey.type !== "public") {
      throw new MlKemInvalidAccessError(
        "Expected publicKey to be an instance of MlKemCryptoKey with type 'public'"
      );
    }
    if (!encapsulationKey.usages.includes(usage)) {
      throw new MlKemInvalidAccessError(`Key usages don't include '${usage}'`);
    }
    const publicKeyData = encapsulationKey[_publicKeyData];
    if (publicKeyData.length !== PUBLICKEY_BYTES) {
      throw new MlKemOperationError("Invalid public key length");
    }
    const coins = crypto.getRandomValues(new Uint8Array(ENC_RANDOM_BYTES));
    const stackSave = module.stackSave();
    try {
      const pkPtr = module.stackAlloc(PUBLICKEY_BYTES);
      const ctPtr = module.stackAlloc(CIPHERTEXT_BYTES);
      const ssPtr = module.stackAlloc(SHARED_SECRET_BYTES);
      const coinsPtr = module.stackAlloc(ENC_RANDOM_BYTES);
      module.HEAPU8.set(publicKeyData, pkPtr);
      module.HEAPU8.set(coins, coinsPtr);
      const result = module._mlkem768_enc_derand(ctPtr, ssPtr, pkPtr, coinsPtr);
      if (result !== 0) {
        throw new MlKemOperationError("Encapsulation failed");
      }
      const ciphertext = new Uint8Array(CIPHERTEXT_BYTES);
      const sharedKey = new Uint8Array(SHARED_SECRET_BYTES);
      ciphertext.set(module.HEAPU8.subarray(ctPtr, ctPtr + CIPHERTEXT_BYTES));
      sharedKey.set(module.HEAPU8.subarray(ssPtr, ssPtr + SHARED_SECRET_BYTES));
      module.HEAPU8.fill(0, ctPtr, ctPtr + CIPHERTEXT_BYTES);
      module.HEAPU8.fill(0, ssPtr, ssPtr + SHARED_SECRET_BYTES);
      module.HEAPU8.fill(0, pkPtr, pkPtr + PUBLICKEY_BYTES);
      module.HEAPU8.fill(0, coinsPtr, coinsPtr + ENC_RANDOM_BYTES);
      return {
        ciphertext: ciphertext.buffer,
        sharedKey: sharedKey.buffer
      };
    } finally {
      module.stackRestore(stackSave);
    }
  }
  async encapsulateBits(algorithm, encapsulationKey) {
    return this.#encapsulate(algorithm, encapsulationKey, "encapsulateBits");
  }
  async encapsulateKey(encapsulationAlgorithm, encapsulationKey, sharedKeyAlgorithm, extractable, usages) {
    const { sharedKey: sharedKeyBits, ciphertext } = await this.#encapsulate(
      encapsulationAlgorithm,
      encapsulationKey,
      "encapsulateKey"
    );
    const sharedKey = await crypto.subtle.importKey(
      "raw",
      sharedKeyBits,
      sharedKeyAlgorithm,
      extractable,
      usages
    );
    return {
      sharedKey,
      ciphertext
    };
  }
  // Internal: implements decapsulateBits without checking key usages.
  async #decapsulate(algorithm, decapsulationKey, ciphertext, usage) {
    const module = await this.#getModule();
    this.#checkAlgorithm(algorithm);
    if (!(decapsulationKey instanceof MlKemCryptoKey) || decapsulationKey.type !== "private") {
      throw new MlKemInvalidAccessError(
        "Expected key to be an instance of MlKemCryptoKey with type 'private'"
      );
    }
    if (!decapsulationKey.usages.includes(usage)) {
      throw new MlKemInvalidAccessError(`Key usages don't include '${usage}'`);
    }
    const secretKeyData = decapsulationKey[_privateSecretKey];
    if (!secretKeyData || secretKeyData.length !== SECRETKEY_BYTES) {
      throw new Error("Invalid secret key length");
    }
    const ct = ArrayBuffer.isView(ciphertext) ? new Uint8Array(
      ciphertext.buffer,
      ciphertext.byteOffset,
      ciphertext.byteLength
    ) : new Uint8Array(ciphertext);
    if (ct.length !== CIPHERTEXT_BYTES) {
      throw new MlKemOperationError("Invalid ciphertext length");
    }
    const stackSave = module.stackSave();
    try {
      const ctPtr = module.stackAlloc(CIPHERTEXT_BYTES);
      const skPtr = module.stackAlloc(SECRETKEY_BYTES);
      const ssPtr = module.stackAlloc(SHARED_SECRET_BYTES);
      module.HEAPU8.set(ct, ctPtr);
      module.HEAPU8.set(secretKeyData, skPtr);
      const result = module._mlkem768_dec(ssPtr, ctPtr, skPtr);
      if (result !== 0) {
        throw new MlKemOperationError("Decapsulation failed");
      }
      const sharedKey = new Uint8Array(SHARED_SECRET_BYTES);
      sharedKey.set(module.HEAPU8.subarray(ssPtr, ssPtr + SHARED_SECRET_BYTES));
      module.HEAPU8.fill(0, ctPtr, ctPtr + CIPHERTEXT_BYTES);
      module.HEAPU8.fill(0, skPtr, skPtr + SECRETKEY_BYTES);
      module.HEAPU8.fill(0, ssPtr, ssPtr + SHARED_SECRET_BYTES);
      return sharedKey.buffer;
    } finally {
      module.stackRestore(stackSave);
    }
  }
  async decapsulateBits(decapsulationAlgorithm, decapsulationKey, ciphertext) {
    return this.#decapsulate(
      decapsulationAlgorithm,
      decapsulationKey,
      ciphertext,
      "decapsulateBits"
    );
  }
  async decapsulateKey(decapsulationAlgorithm, decapsulationKey, ciphertext, sharedKeyAlgorithm, extractable, usages) {
    const sharedKeyBits = await this.#decapsulate(
      decapsulationAlgorithm,
      decapsulationKey,
      ciphertext,
      "decapsulateKey"
    );
    const sharedKey = await crypto.subtle.importKey(
      "raw",
      sharedKeyBits,
      sharedKeyAlgorithm,
      extractable,
      usages
    );
    return sharedKey;
  }
};
var mlkem_default = new MlKem768();
export {
  mlkem_default as default
};
