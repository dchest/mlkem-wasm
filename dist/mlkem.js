// src/build/wasm-module.js
async function MLKEM768Module(moduleArg = {}) {
  var moduleRtn;
  var Module = moduleArg;
  var ENVIRONMENT_IS_WEB = typeof window == "object";
  var ENVIRONMENT_IS_WORKER = typeof WorkerGlobalScope != "undefined";
  var ENVIRONMENT_IS_NODE = typeof process == "object" && process.versions?.node && process.type != "renderer";
  var _scriptName = import.meta.url;
  var scriptDirectory = "";
  var readAsync, readBinary;
  if (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) {
    try {
      scriptDirectory = new URL(".", _scriptName).href;
    } catch {
    }
    {
      if (ENVIRONMENT_IS_WORKER) {
        readBinary = (url) => {
          var xhr = new XMLHttpRequest();
          xhr.open("GET", url, false);
          xhr.responseType = "arraybuffer";
          xhr.send(null);
          return new Uint8Array(xhr.response);
        };
      }
      readAsync = async (url) => {
        if (isFileURI(url)) {
          return new Promise((resolve, reject) => {
            var xhr = new XMLHttpRequest();
            xhr.open("GET", url, true);
            xhr.responseType = "arraybuffer";
            xhr.onload = () => {
              if (xhr.status == 200 || xhr.status == 0 && xhr.response) {
                resolve(xhr.response);
                return;
              }
              reject(xhr.status);
            };
            xhr.onerror = reject;
            xhr.send(null);
          });
        }
        var response = await fetch(url, { credentials: "same-origin" });
        if (response.ok) {
          return response.arrayBuffer();
        }
        throw new Error(response.status + " : " + response.url);
      };
    }
  } else {
  }
  var out = console.log.bind(console);
  var err = console.error.bind(console);
  var wasmBinary;
  var ABORT = false;
  var isFileURI = (filename) => filename.startsWith("file://");
  var readyPromiseResolve, readyPromiseReject;
  var wasmMemory;
  var HEAP8, HEAPU8, HEAP16, HEAPU16, HEAP32, HEAPU32, HEAPF32, HEAPF64;
  var HEAP64, HEAPU64;
  var runtimeInitialized = false;
  function updateMemoryViews() {
    var b = wasmMemory.buffer;
    Module["HEAP8"] = HEAP8 = new Int8Array(b);
    HEAP16 = new Int16Array(b);
    Module["HEAPU8"] = HEAPU8 = new Uint8Array(b);
    HEAPU16 = new Uint16Array(b);
    HEAP32 = new Int32Array(b);
    HEAPU32 = new Uint32Array(b);
    HEAPF32 = new Float32Array(b);
    HEAPF64 = new Float64Array(b);
    HEAP64 = new BigInt64Array(b);
    HEAPU64 = new BigUint64Array(b);
  }
  function preRun() {
  }
  function initRuntime() {
    runtimeInitialized = true;
    wasmExports["b"]();
  }
  function postRun() {
  }
  function abort(what) {
    what = "Aborted(" + what + ")";
    err(what);
    ABORT = true;
    what += ". Build with -sASSERTIONS for more info.";
    var e = new WebAssembly.RuntimeError(what);
    readyPromiseReject?.(e);
    throw e;
  }
  var wasmBinaryFile;
  function findWasmBinary() {
    return base64Decode("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CCIBIAAtABtzIAJxIAFzOgAbIAAgAy0A/AgiASAALQAccyACcSABczoAHCAAIAMtAP0IIgEgAC0AHXMgAnEgAXM6AB0gACADLQD+CCIBIAAtAB5zIAJxIAFzOgAeIAAgAiADLQD/CCIBIAAtAB9zcSABczoAHyADQdgJakIANwMAIANB0AlqQgA3AwAgA0HICWpCADcDACADQcAJakIANwMAIANCADcDuAkgA0IANwOwCSADQgA3A6gJIANCADcDoAkgA0GYCWpCADcDACADQZAJakIANwMAIANBiAlqQgA3AwAgA0GACWpCADcDACADQgA3A/gIIANCADcD8AggA0IANwPoCCADQgA3A+AIIANBAEHgCPwLAEEAIQcLJAAgBwvPAwEIfyMAIgQgBEGAFWtBYHEiBCQAIARBgAlqIgUgAhANIAUQDCAEIAUQDkEAIQUDQCAEIAZBAmoiB2otAAAgAiAHai0AAHMiByAEIAZBAWoiCWotAAAgAiAJai0AAHMiCSAEIAZqLQAAIAIgBmotAABzIgsgCHNzcyEIIAcgCSAFIAtycnIhBSAGQQNqIgZBgAlHDQALIARBAEGACfwLACAEQYAJaiIGQQBBgAz8CwAgCEEAIAVB/wFxa0EYdnNBfyEFQf8BcSAIQf8BcUYEQCAEIAMpAAA3A4AJIAQgAykAGDcDmAkgBCADKQAQNwOQCSAEIAMpAAg3A4gJIARBoAlqIgMgAhATIAQgBkHAABASIAAgBiACIARBIGoQGiABIAQpAxg3ABggASAEKQMQNwAQIAEgBCkDCDcACCABIAQpAwA3AAAgA0IANwMAIARBqAlqQgA3AwAgBEGwCWpCADcDACAEQbgJakIANwMAIARCADcDgAkgBEIANwOICSAEQgA3A5AJIARCADcDmAkgBEIANwM4IARCADcDMCAEQgA3AyggBEIANwMgIARCADcDGCAEQgA3AxAgBEIANwMIIARCADcDAEEAIQULJAAgBQuVBwIKfwR+IwAiAyADQYDPAGtBYHEiAyQAIAIpAAghDSACKQAQIQ4gAikAGCEPIAIpAAAhECADQQM6ACAgAyAPNwMYIAMgDjcDECADIA03AwggAyAQNwMAIANBwM4AaiADQSEQEiADQYgfaiADKQPITiINNwMAIANBkB9qIAMpA9BOIg43AwAgA0GYH2ogAykD2E4iDzcDACADQcgfaiANNwMAIANB0B9qIA43AwAgA0HYH2ogDzcDACADQZggaiAPNwMAIANBkCBqIA43AwAgA0GIIGogDTcDACADIA83A9geIAMgDjcD0B4gAyANNwPIHiADIAMpA8BOIg03A8AeIAMgDTcDgB8gAyANNwPAHyADIA03A4AgIANBgAI7AaAgIANBAjsB4B8gA0EBOwGgHyADQQA7AeAeIANBwCpqIgggA0HALmogA0HAMmogA0HANmoiCyADQcAeaiIGEAogA0GBBDsBoCAgA0GABDsB4B8gA0GCAjsBoB8gA0GBAjsB4B4gA0HAOmogA0HAPmogA0HAwgBqIgwgA0HAxgBqIAYQCiADQYIEOwHgHiADQcDKAGogBhAfIAZBAEGAAvwLACADQcAGaiIEIANBwApqIANBwA5qIANBwBJqIgUgA0HgzgBqIglBAEEBQQJB/wEQCyAGIANBwCJqIANBwCZqIAUgCUEDQQRBBUH/ARALIAQQBiAGEAYgA0FAayIHIAQQGCAFIAggBCAHEAIgA0HAFmogCyAEIAcQAiADQcAaaiAMIAQgBxACIAUQFyAFQYAEahAXIAVBgAhqEBcgBSAGECAgBRAMIAQQDCABIAQQDiAAIAUQDiAAQZgJaiADKQPYTjcAACAAQZAJaiADKQPQTjcAACAAQYgJaiADKQPITjcAACAAIAMpA8BONwCACSAJQgA3AwAgA0HozgBqQgA3AwAgA0HwzgBqQgA3AwAgA0H4zgBqQgA3AwAgA0IANwPATiADQgA3A8hOIANCADcD0E4gA0IANwPYTiADQQA6ACAgA0IANwMYIANCADcDECADQgA3AwggA0IANwMAIAhBAEGAJPwLACAGQQBBgAz8CwAgBEEAQYAM/AsAIAdBAEGABvwLACQAIAFBgAlqIABBoAn8CgAAIAFBoBJqIAAQEyABQdgSaiACKQA4NwAAIAFB0BJqIAIpADA3AAAgAUHIEmogAikAKDcAACABIAIpACA3AMASQQALAgALC8gDAQBBgAgLwAPs+wr9mf4T+tUFjgUfAcoAVf9uAikGtgDCA077Pvq8BT0C0/oIAX8Bw/yyBb75fv9X/fkD3AJgAvr5mwEz/935xwSMAtj99wPz+tMF5v74+QQC+P/A/mb9rvl2+34AvQWr/Kb/8f4+A2sAc/oJ/0n8cv7BAxz6K/3AAdf7pQIF+7H7rgErAksDHftnAw4GaQCmAUsCsQAV/93+NP4mBnUGCv8KA4cEbf/3/MsFpv1fBMr5hAKY/F0BogFJAWT/tf8xA0kEWwJiAioF+/pH+oABQft4/8IEyfqW/NwAXfuF+V/7BvoC+xoDGvqq/Jr83gGU/8z+5APfA74DTPryBVwGAQAAAAAAAACCgAAAAAAAAIqAAAAAAACAAIAAgAAAAICLgAAAAAAAAAEAAIAAAAAAgYAAgAAAAIAJgAAAAAAAgIoAAAAAAAAAiAAAAAAAAAAJgACAAAAAAAoAAIAAAAAAi4AAgAAAAACLAAAAAAAAgImAAAAAAACAA4AAAAAAAIACgAAAAAAAgIAAAAAAAACACoAAAAAAAAAKAACAAAAAgIGAAIAAAACAgIAAAAAAAIABAACAAAAAAAiAAIAAAACA");
  }
  function getBinarySync(file) {
    if (ArrayBuffer.isView(file)) {
      return file;
    }
    if (readBinary) {
      return readBinary(file);
    }
    throw "both async and sync fetching of the wasm failed";
  }
  async function getWasmBinary(binaryFile) {
    return getBinarySync(binaryFile);
  }
  async function instantiateArrayBuffer(binaryFile, imports) {
    try {
      var binary = await getWasmBinary(binaryFile);
      var instance = await WebAssembly.instantiate(binary, imports);
      return instance;
    } catch (reason) {
      err(`failed to asynchronously prepare wasm: ${reason}`);
      abort(reason);
    }
  }
  async function instantiateAsync(binary, binaryFile, imports) {
    return instantiateArrayBuffer(binaryFile, imports);
  }
  function getWasmImports() {
    return { a: wasmImports };
  }
  async function createWasm() {
    function receiveInstance(instance, module) {
      wasmExports = instance.exports;
      wasmMemory = wasmExports["a"];
      updateMemoryViews();
      assignWasmExports(wasmExports);
      return wasmExports;
    }
    function receiveInstantiationResult(result2) {
      return receiveInstance(result2["instance"]);
    }
    var info = getWasmImports();
    wasmBinaryFile ??= findWasmBinary();
    var result = await instantiateAsync(wasmBinary, wasmBinaryFile, info);
    var exports = receiveInstantiationResult(result);
    return exports;
  }
  class ExitStatus {
    name = "ExitStatus";
    constructor(status) {
      this.message = `Program terminated with exit(${status})`;
      this.status = status;
    }
  }
  var base64Decode = (b64) => {
    var b1, b2, i2 = 0, j = 0, bLength = b64.length;
    var output = new Uint8Array((bLength * 3 >> 2) - (b64[bLength - 2] == "=") - (b64[bLength - 1] == "="));
    for (; i2 < bLength; i2 += 4, j += 3) {
      b1 = base64ReverseLookup[b64.charCodeAt(i2 + 1)];
      b2 = base64ReverseLookup[b64.charCodeAt(i2 + 2)];
      output[j] = base64ReverseLookup[b64.charCodeAt(i2)] << 2 | b1 >> 4;
      output[j + 1] = b1 << 4 | b2 >> 2;
      output[j + 2] = b2 << 6 | base64ReverseLookup[b64.charCodeAt(i2 + 3)];
    }
    return output;
  };
  function getValue(ptr, type = "i8") {
    if (type.endsWith("*")) type = "*";
    switch (type) {
      case "i1":
        return HEAP8[ptr];
      case "i8":
        return HEAP8[ptr];
      case "i16":
        return HEAP16[ptr >> 1];
      case "i32":
        return HEAP32[ptr >> 2];
      case "i64":
        return HEAP64[ptr >> 3];
      case "float":
        return HEAPF32[ptr >> 2];
      case "double":
        return HEAPF64[ptr >> 3];
      case "*":
        return HEAPU32[ptr >> 2];
      default:
        abort(`invalid type for getValue: ${type}`);
    }
  }
  function setValue(ptr, value, type = "i8") {
    if (type.endsWith("*")) type = "*";
    switch (type) {
      case "i1":
        HEAP8[ptr] = value;
        break;
      case "i8":
        HEAP8[ptr] = value;
        break;
      case "i16":
        HEAP16[ptr >> 1] = value;
        break;
      case "i32":
        HEAP32[ptr >> 2] = value;
        break;
      case "i64":
        HEAP64[ptr >> 3] = BigInt(value);
        break;
      case "float":
        HEAPF32[ptr >> 2] = value;
        break;
      case "double":
        HEAPF64[ptr >> 3] = value;
        break;
      case "*":
        HEAPU32[ptr >> 2] = value;
        break;
      default:
        abort(`invalid type for setValue: ${type}`);
    }
  }
  var stackRestore = (val) => __emscripten_stack_restore(val);
  var stackSave = () => _emscripten_stack_get_current();
  var stackAlloc = (sz) => __emscripten_stack_alloc(sz);
  for (var base64ReverseLookup = new Uint8Array(123), i = 25; i >= 0; --i) {
    base64ReverseLookup[48 + i] = 52 + i;
    base64ReverseLookup[65 + i] = i;
    base64ReverseLookup[97 + i] = 26 + i;
  }
  base64ReverseLookup[43] = 62;
  base64ReverseLookup[47] = 63;
  {
  }
  Module["stackSave"] = stackSave;
  Module["stackRestore"] = stackRestore;
  Module["stackAlloc"] = stackAlloc;
  Module["setValue"] = setValue;
  Module["getValue"] = getValue;
  var _mlkem768_keypair_derand, _mlkem768_enc_derand, _mlkem768_dec, __emscripten_stack_restore, __emscripten_stack_alloc, _emscripten_stack_get_current;
  function assignWasmExports(wasmExports2) {
    Module["_mlkem768_keypair_derand"] = _mlkem768_keypair_derand = wasmExports2["c"];
    Module["_mlkem768_enc_derand"] = _mlkem768_enc_derand = wasmExports2["d"];
    Module["_mlkem768_dec"] = _mlkem768_dec = wasmExports2["e"];
    __emscripten_stack_restore = wasmExports2["f"];
    __emscripten_stack_alloc = wasmExports2["g"];
    _emscripten_stack_get_current = wasmExports2["h"];
  }
  var wasmImports = {};
  function run() {
    preRun();
    function doRun() {
      Module["calledRun"] = true;
      if (ABORT) return;
      initRuntime();
      readyPromiseResolve?.(Module);
      postRun();
    }
    {
      doRun();
    }
  }
  var wasmExports;
  wasmExports = await createWasm();
  run();
  if (runtimeInitialized) {
    moduleRtn = Module;
  } else {
    moduleRtn = new Promise((resolve, reject) => {
      readyPromiseResolve = resolve;
      readyPromiseReject = reject;
    });
  }
  ;
  return moduleRtn;
}
var wasm_module_default = MLKEM768Module;

// src/mlkem.ts
var ALGORITHM_NAME = "ML-KEM-768";
var JWK_ALG = "MLKEM768";
var KEY_USAGES = [
  "encapsulateKey",
  "encapsulateBits",
  "decapsulateKey",
  "decapsulateBits"
];
var MlKemOperationError = class extends Error {
  constructor(message) {
    super(message);
    this.name = "OperationError";
  }
};
var MlKemInvalidAccessError = class extends Error {
  constructor(message) {
    super(message);
    this.name = "InvalidAccessError";
  }
};
var MlKemNotSupportedError = class extends Error {
  constructor(message) {
    super(message);
    this.name = "NotSupportedError";
  }
};
var MlKemDataError = class extends Error {
  constructor(message) {
    super(message);
    this.name = "DataError";
  }
};
var internalKeyData = /* @__PURE__ */ new WeakMap();
function getInternalKeyData(key) {
  const keyData = internalKeyData.get(key);
  if (!keyData) {
    throw new TypeError("Unknown key object");
  }
  return keyData;
}
var cleanupRegistry = new FinalizationRegistry((keyData) => {
  keyData.publicKeyData.fill(0);
  keyData.privateSeedData?.fill(0);
  keyData.privateSecretKeyData?.fill(0);
});
function getPublicKeyDataRef(key) {
  const keyData = getInternalKeyData(key);
  if (!keyData.publicKeyData) {
    throw new MlKemOperationError("Failed to get public key data");
  }
  return keyData.publicKeyData;
}
function getPrivateKeyDataRef(key) {
  const keyData = getInternalKeyData(key);
  if (!keyData.privateSeedData || !keyData.privateSecretKeyData) {
    throw new MlKemOperationError("Failed to get private key data");
  }
  return keyData;
}
var noClone = Symbol("CryptoKey created by mlkem-wasm cannot be cloned");
var keyIdKey = "_mlkem_wasm";
var emptyToJSON = () => ({});
function createKeyObject(type, extractable, usages, keyData) {
  const key = {
    type,
    extractable,
    algorithm: Object.freeze({ name: ALGORITHM_NAME }),
    usages: Object.freeze(Array.from(usages)),
    [keyIdKey]: noClone
    // to prevent structured cloning
  };
  Object.defineProperty(key, "toJSON", {
    value: emptyToJSON,
    writable: false,
    enumerable: false,
    configurable: false
  });
  Object.setPrototypeOf(key, CryptoKey.prototype);
  internalKeyData.set(key, keyData);
  cleanupRegistry.register(key, keyData);
  return Object.freeze(key);
}
function createPublicKey(publicKeyData, usages) {
  return createKeyObject("public", true, usages, { publicKeyData });
}
function createPrivateKey(publicKeyData, privateSeedData, privateSecretKeyData, extractable, usages) {
  return createKeyObject("private", extractable, usages, {
    publicKeyData,
    privateSeedData,
    privateSecretKeyData
  });
}
function _isSupportedCryptoKey(key) {
  return key instanceof CryptoKey && keyIdKey in key && key[keyIdKey] == noClone && internalKeyData.has(key);
}
function toBase64url(data) {
  return btoa(String.fromCharCode(...data)).replace(/\+/g, "-").replace(/\//g, "_").replace(/=+$/, "");
}
function fromBase64url(base64url) {
  const base64 = base64url.replace(/-/g, "+").replace(/_/g, "/");
  const binary = atob(base64 + "===".slice((base64.length + 3) % 4));
  return Uint8Array.from(binary, (c) => c.charCodeAt(0));
}
var PUBLICKEY_BYTES = 1184;
var SECRETKEY_BYTES = 2400;
var CIPHERTEXT_BYTES = 1088;
var SHARED_SECRET_BYTES = 32;
var KEYPAIR_RANDOM_BYTES = 64;
var ENC_RANDOM_BYTES = 32;
var _module;
async function getModule() {
  if (!_module) {
    _module = await wasm_module_default();
  }
  return _module;
}
var getRandomValues = crypto.getRandomValues.bind(crypto);
function checkAlgorithm(algorithm) {
  const name = typeof algorithm === "string" ? algorithm.toUpperCase() : typeof algorithm === "object" && algorithm !== null && "name" in algorithm && typeof algorithm.name === "string" ? algorithm.name.toUpperCase() : null;
  if (name !== ALGORITHM_NAME) {
    throw new TypeError("Unsupported algorithm");
  }
}
async function internalGenerateKeyPair(coins) {
  const module = await getModule();
  const stackSave = module.stackSave();
  try {
    const pkPtr = module.stackAlloc(PUBLICKEY_BYTES);
    const skPtr = module.stackAlloc(SECRETKEY_BYTES);
    const coinsPtr = module.stackAlloc(KEYPAIR_RANDOM_BYTES);
    module.HEAPU8.set(coins, coinsPtr);
    const result = module._mlkem768_keypair_derand(pkPtr, skPtr, coinsPtr);
    if (result !== 0) {
      throw new MlKemOperationError("Key generation failed");
    }
    const rawPublicKey = new Uint8Array(PUBLICKEY_BYTES);
    const rawSecretKey = new Uint8Array(SECRETKEY_BYTES);
    const rawSeed = new Uint8Array(coins);
    rawPublicKey.set(module.HEAPU8.subarray(pkPtr, pkPtr + PUBLICKEY_BYTES));
    rawSecretKey.set(module.HEAPU8.subarray(skPtr, skPtr + SECRETKEY_BYTES));
    module.HEAPU8.fill(0, pkPtr, pkPtr + PUBLICKEY_BYTES);
    module.HEAPU8.fill(0, skPtr, skPtr + SECRETKEY_BYTES);
    module.HEAPU8.fill(0, coinsPtr, coinsPtr + KEYPAIR_RANDOM_BYTES);
    return { rawPublicKey, rawSecretKey, rawSeed };
  } finally {
    module.stackRestore(stackSave);
  }
}
async function generateKey(keyAlgorithm, extractable, usages) {
  checkAlgorithm(keyAlgorithm);
  if (!Array.isArray(usages) || usages.some((usage) => !KEY_USAGES.includes(usage))) {
    throw new SyntaxError("Invalid key usages");
  }
  const { rawPublicKey, rawSecretKey, rawSeed } = await internalGenerateKeyPair(
    getRandomValues(new Uint8Array(KEYPAIR_RANDOM_BYTES))
  );
  const publicKey = createPublicKey(
    rawPublicKey,
    usages.filter(
      (usage) => usage === "encapsulateKey" || usage === "encapsulateBits"
    )
  );
  const privateKey = createPrivateKey(
    rawPublicKey,
    rawSeed,
    rawSecretKey,
    extractable,
    usages.filter(
      (usage) => usage === "decapsulateKey" || usage === "decapsulateBits"
    )
  );
  return {
    publicKey,
    privateKey
  };
}
async function exportKey(format, key) {
  if (!(key instanceof CryptoKey)) {
    throw new TypeError("Expected key to be an instance of CryptoKey");
  }
  checkAlgorithm(key.algorithm);
  if (!key.extractable) {
    throw new MlKemOperationError("Key is not extractable");
  }
  if (format === "spki") {
    if (key.type !== "public") {
      throw new TypeError("Expected key type to be 'public'");
    }
    return rawToDer(MLKEM768_SPKI, getPublicKeyDataRef(key)).buffer;
  }
  if (format === "pkcs8") {
    if (key.type !== "private") {
      throw new MlKemInvalidAccessError("Expected key type to be 'private'");
    }
    return rawToDer(MLKEM768_PKCS8, getPrivateKeyDataRef(key).privateSeedData).buffer;
  }
  if (format === "raw-public") {
    if (key.type !== "public") {
      throw new TypeError("Expected key type to be 'public'");
    }
    return new Uint8Array(getPublicKeyDataRef(key)).buffer;
  }
  if (format === "raw-seed") {
    if (key.type !== "private") {
      throw new MlKemInvalidAccessError("Expected key type to be 'private'");
    }
    return new Uint8Array(getPrivateKeyDataRef(key).privateSeedData).buffer;
  }
  if (format === "jwk") {
    const jwk = {
      // 2.2. Set the kty attribute of jwk to "AKP".
      kty: "AKP",
      // 2.3. Set the alg attribute of jwk to the alg value corresponding to
      // the name member of normalizedAlgorithm indicated in Section 8 of
      // [draft-ietf-jose-pqc-kem-01] (Figure 1).
      alg: JWK_ALG,
      // 2.4. Set the pub attribute of jwk to the base64url encoded public
      // key corresponding to the [[handle]] internal slot of key.
      pub: toBase64url(getPublicKeyDataRef(key))
    };
    if (key.type === "private") {
      jwk.priv = toBase64url(getPrivateKeyDataRef(key).privateSeedData);
    }
    jwk.key_ops = key.usages;
    jwk.ext = key.extractable;
    return jwk;
  }
  throw new MlKemNotSupportedError("Format not supported");
}
function bufferSourcetoUint8Array(value) {
  if (ArrayBuffer.isView(value) && value.buffer instanceof ArrayBuffer) {
    return new Uint8Array(value.buffer, value.byteOffset, value.byteLength);
  } else if (value instanceof ArrayBuffer) {
    return new Uint8Array(value);
  } else {
    throw new TypeError("Value must be a BufferSource");
  }
}
function bufferSourcetoUint8ArrayCopy(value) {
  return bufferSourcetoUint8Array(value).slice();
}
var MLKEM768_SPKI = {
  fullLength: 1206,
  prefix: new Uint8Array([
    48,
    130,
    4,
    178,
    48,
    11,
    6,
    9,
    96,
    134,
    72,
    1,
    101,
    3,
    4,
    4,
    2,
    3,
    130,
    4,
    161,
    0
  ])
};
var MLKEM768_PKCS8 = {
  fullLength: 86,
  prefix: new Uint8Array([
    48,
    84,
    2,
    1,
    0,
    48,
    11,
    6,
    9,
    96,
    134,
    72,
    1,
    101,
    3,
    4,
    4,
    2,
    4,
    66,
    128,
    64
  ])
};
function bytesEqual(a, b) {
  if (a.length !== b.length) {
    return false;
  }
  let diff = 0;
  for (let i = 0; i < a.length; i++) {
    diff |= a[i] ^ b[i];
  }
  return diff === 0;
}
function derToRaw(encoding, der) {
  if (der.length !== encoding.fullLength) {
    throw new MlKemDataError("Invalid encoding");
  }
  const prefix = der.subarray(0, encoding.prefix.length);
  if (!bytesEqual(prefix, encoding.prefix)) {
    throw new MlKemNotSupportedError("Unsupported encoding");
  }
  return der.slice(encoding.prefix.length);
}
function rawToDer(encoding, raw) {
  const der = new Uint8Array(encoding.fullLength);
  der.set(encoding.prefix);
  der.set(raw, encoding.prefix.length);
  return der;
}
async function importKey(format, keyData, algorithm, extractable, usages) {
  checkAlgorithm(algorithm);
  if (format === "spki") {
    if (!Array.isArray(usages) || usages.some(
      (usage) => usage !== "encapsulateKey" && usage !== "encapsulateBits"
    )) {
      throw new SyntaxError("Invalid key usages for public key");
    }
    const data = derToRaw(MLKEM768_SPKI, bufferSourcetoUint8Array(keyData));
    if (data.length !== PUBLICKEY_BYTES) {
      throw new MlKemDataError("Invalid key length");
    }
    return createPublicKey(data, usages);
  }
  if (format === "pkcs8") {
    if (!Array.isArray(usages) || usages.some(
      (usage) => usage !== "decapsulateKey" && usage !== "decapsulateBits"
    )) {
      throw new SyntaxError("Invalid key usages for private key");
    }
    const data = derToRaw(MLKEM768_PKCS8, bufferSourcetoUint8Array(keyData));
    if (data.length !== KEYPAIR_RANDOM_BYTES) {
      throw new MlKemDataError("Invalid key length");
    }
    const { rawPublicKey, rawSecretKey, rawSeed } = await internalGenerateKeyPair(data);
    return createPrivateKey(
      rawPublicKey,
      rawSeed,
      rawSecretKey,
      extractable,
      usages
    );
  }
  if (format === "raw-public") {
    if (!Array.isArray(usages) || usages.some(
      (usage) => usage !== "encapsulateKey" && usage !== "encapsulateBits"
    )) {
      throw new SyntaxError("Invalid key usages for public key");
    }
    const data = bufferSourcetoUint8ArrayCopy(keyData);
    return createPublicKey(data, usages);
  }
  if (format === "raw-seed") {
    if (!Array.isArray(usages) || usages.some(
      (usage) => usage !== "decapsulateKey" && usage !== "decapsulateBits"
    )) {
      throw new SyntaxError("Invalid key usages for private key");
    }
    const data = bufferSourcetoUint8ArrayCopy(keyData);
    if (data.length !== KEYPAIR_RANDOM_BYTES) {
      throw new MlKemDataError("Invalid key length");
    }
    const { rawPublicKey, rawSecretKey, rawSeed } = await internalGenerateKeyPair(data);
    return createPrivateKey(
      rawPublicKey,
      rawSeed,
      rawSecretKey,
      extractable,
      usages
    );
  }
  if (format === "jwk") {
    if (typeof keyData !== "object" || keyData === null) {
      throw new MlKemDataError(
        "Expected keyData to be a JsonWebKey dictionary"
      );
    }
    const jwk = keyData;
    if (jwk.priv && usages.some(
      (usage) => usage !== "decapsulateKey" && usage !== "decapsulateBits"
    )) {
      throw new SyntaxError("Invalid key usages for private key");
    }
    if (!jwk.priv && usages.some(
      (usage) => usage !== "encapsulateKey" && usage !== "encapsulateBits"
    )) {
      throw new SyntaxError("Invalid key usages for public key");
    }
    if (jwk.kty !== "AKP") {
      throw new MlKemDataError("Invalid key type");
    }
    if (jwk.alg !== JWK_ALG && jwk.alg !== "ML-KEM-768+A192KW") {
      throw new MlKemDataError("Invalid algorithm");
    }
    if (usages.length > 0 && jwk.use && jwk.use !== "enc") {
      throw new MlKemDataError("Invalid key usage");
    }
    if (jwk.key_ops && Array.isArray(jwk.key_ops) && !Array.prototype.every.call(
      jwk.key_ops,
      (op) => KEY_USAGES.includes(op)
    ) || !Array.isArray(jwk.key_ops)) {
      throw new MlKemDataError("Invalid key operations");
    }
    if (jwk.ext === false && extractable) {
      throw new MlKemDataError("Invalid key extractability");
    }
    if (jwk.priv) {
      try {
        const seedData = fromBase64url(jwk.priv);
        if (seedData.length !== KEYPAIR_RANDOM_BYTES) {
          throw new MlKemDataError("Invalid private key length");
        }
        const { rawPublicKey, rawSecretKey, rawSeed } = await internalGenerateKeyPair(seedData);
        const key = createPrivateKey(
          rawPublicKey,
          rawSeed,
          rawSecretKey,
          extractable,
          usages
        );
        if (toBase64url(rawPublicKey) !== jwk.pub) {
          throw new MlKemDataError("Invalid public key data");
        }
        return key;
      } catch {
        throw new MlKemDataError("Invalid private key format");
      }
    } else {
      try {
        const publicKeyData = fromBase64url(jwk.pub);
        if (publicKeyData.length !== PUBLICKEY_BYTES) {
          throw new MlKemDataError("Invalid public key data");
        }
        return createPublicKey(publicKeyData, usages);
      } catch {
        throw new MlKemDataError("Invalid public key format");
      }
    }
  }
  throw new MlKemNotSupportedError("Unsupported key format");
}
async function getPublicKey(key, usages) {
  if (!(key instanceof CryptoKey)) {
    throw new TypeError("Expected key to be an instance of CryptoKey");
  }
  checkAlgorithm(key.algorithm);
  if (key.type !== "private") {
    throw new MlKemInvalidAccessError("Expected key type to be 'private'");
  }
  if (!Array.isArray(usages) || usages.some(
    (usage) => usage !== "encapsulateKey" && usage !== "encapsulateBits"
  )) {
    throw new SyntaxError("Invalid key usages");
  }
  const keyData = getInternalKeyData(key);
  if (!keyData.publicKeyData) {
    throw new MlKemOperationError("Failed to get public key data");
  }
  return createPublicKey(new Uint8Array(keyData.publicKeyData), usages);
}
async function internalEncapsulate(algorithm, encapsulationKey, usage) {
  const module = await getModule();
  checkAlgorithm(algorithm);
  if (!(encapsulationKey instanceof CryptoKey) || encapsulationKey.type !== "public") {
    throw new MlKemInvalidAccessError(
      "Expected publicKey to be an instance of MlKemCryptoKey with type 'public'"
    );
  }
  if (!encapsulationKey.usages.includes(usage)) {
    throw new MlKemInvalidAccessError(`Key usages don't include '${usage}'`);
  }
  const publicKeyData = getPublicKeyDataRef(encapsulationKey);
  if (publicKeyData.length !== PUBLICKEY_BYTES) {
    throw new MlKemOperationError("Invalid public key length");
  }
  const coins = getRandomValues(new Uint8Array(ENC_RANDOM_BYTES));
  const stackSave = module.stackSave();
  try {
    const pkPtr = module.stackAlloc(PUBLICKEY_BYTES);
    const ctPtr = module.stackAlloc(CIPHERTEXT_BYTES);
    const ssPtr = module.stackAlloc(SHARED_SECRET_BYTES);
    const coinsPtr = module.stackAlloc(ENC_RANDOM_BYTES);
    module.HEAPU8.set(publicKeyData, pkPtr);
    module.HEAPU8.set(coins, coinsPtr);
    const result = module._mlkem768_enc_derand(ctPtr, ssPtr, pkPtr, coinsPtr);
    if (result !== 0) {
      throw new MlKemOperationError("Encapsulation failed");
    }
    const ciphertext = new Uint8Array(CIPHERTEXT_BYTES);
    const sharedKey = new Uint8Array(SHARED_SECRET_BYTES);
    ciphertext.set(module.HEAPU8.subarray(ctPtr, ctPtr + CIPHERTEXT_BYTES));
    sharedKey.set(module.HEAPU8.subarray(ssPtr, ssPtr + SHARED_SECRET_BYTES));
    module.HEAPU8.fill(0, ctPtr, ctPtr + CIPHERTEXT_BYTES);
    module.HEAPU8.fill(0, ssPtr, ssPtr + SHARED_SECRET_BYTES);
    module.HEAPU8.fill(0, pkPtr, pkPtr + PUBLICKEY_BYTES);
    module.HEAPU8.fill(0, coinsPtr, coinsPtr + ENC_RANDOM_BYTES);
    return {
      ciphertext: ciphertext.buffer,
      sharedKey: sharedKey.buffer
    };
  } finally {
    module.stackRestore(stackSave);
  }
}
async function encapsulateBits(algorithm, encapsulationKey) {
  return internalEncapsulate(algorithm, encapsulationKey, "encapsulateBits");
}
async function encapsulateKey(encapsulationAlgorithm, encapsulationKey, sharedKeyAlgorithm, extractable, usages) {
  const { sharedKey: sharedKeyBits, ciphertext } = await internalEncapsulate(
    encapsulationAlgorithm,
    encapsulationKey,
    "encapsulateKey"
  );
  const sharedKey = await crypto.subtle.importKey(
    "raw",
    sharedKeyBits,
    sharedKeyAlgorithm,
    extractable,
    usages
  );
  return {
    sharedKey,
    ciphertext
  };
}
async function internalDecapsulate(algorithm, decapsulationKey, ciphertext, usage) {
  const module = await getModule();
  checkAlgorithm(algorithm);
  if (!(decapsulationKey instanceof CryptoKey) || decapsulationKey.type !== "private") {
    throw new MlKemInvalidAccessError(
      "Expected key to be an instance of MlKemCryptoKey with type 'private'"
    );
  }
  if (!decapsulationKey.usages.includes(usage)) {
    throw new MlKemInvalidAccessError(`Key usages don't include '${usage}'`);
  }
  const secretKeyData = getPrivateKeyDataRef(decapsulationKey).privateSecretKeyData;
  if (!secretKeyData || secretKeyData.length !== SECRETKEY_BYTES) {
    throw new Error("Invalid secret key length");
  }
  const ct = bufferSourcetoUint8Array(ciphertext);
  if (ct.length !== CIPHERTEXT_BYTES) {
    throw new MlKemOperationError("Invalid ciphertext length");
  }
  const stackSave = module.stackSave();
  try {
    const ctPtr = module.stackAlloc(CIPHERTEXT_BYTES);
    const skPtr = module.stackAlloc(SECRETKEY_BYTES);
    const ssPtr = module.stackAlloc(SHARED_SECRET_BYTES);
    module.HEAPU8.set(ct, ctPtr);
    module.HEAPU8.set(secretKeyData, skPtr);
    const result = module._mlkem768_dec(ssPtr, ctPtr, skPtr);
    if (result !== 0) {
      throw new MlKemOperationError("Decapsulation failed");
    }
    const sharedKey = new Uint8Array(SHARED_SECRET_BYTES);
    sharedKey.set(module.HEAPU8.subarray(ssPtr, ssPtr + SHARED_SECRET_BYTES));
    module.HEAPU8.fill(0, ctPtr, ctPtr + CIPHERTEXT_BYTES);
    module.HEAPU8.fill(0, skPtr, skPtr + SECRETKEY_BYTES);
    module.HEAPU8.fill(0, ssPtr, ssPtr + SHARED_SECRET_BYTES);
    return sharedKey.buffer;
  } finally {
    module.stackRestore(stackSave);
  }
}
async function decapsulateBits(decapsulationAlgorithm, decapsulationKey, ciphertext) {
  return internalDecapsulate(
    decapsulationAlgorithm,
    decapsulationKey,
    ciphertext,
    "decapsulateBits"
  );
}
async function decapsulateKey(decapsulationAlgorithm, decapsulationKey, ciphertext, sharedKeyAlgorithm, extractable, usages) {
  const sharedKeyBits = await internalDecapsulate(
    decapsulationAlgorithm,
    decapsulationKey,
    ciphertext,
    "decapsulateKey"
  );
  const sharedKey = await crypto.subtle.importKey(
    "raw",
    sharedKeyBits,
    sharedKeyAlgorithm,
    extractable,
    usages
  );
  return sharedKey;
}
var mlkem = {
  generateKey,
  exportKey,
  importKey,
  getPublicKey,
  encapsulateBits,
  encapsulateKey,
  decapsulateBits,
  decapsulateKey,
  _isSupportedCryptoKey
};
var mlkem_default = mlkem;
export {
  mlkem_default as default
};
